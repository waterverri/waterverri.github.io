<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Waterverri's Advanced BBCode Text Watermarker v20</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { font-family: 'Inter', sans-serif; background-color: #f0f2f5; }
        .container { max-width: 1200px; background-color: #ffffff; }
        .range-value { display: inline-block; min-width: 40px; text-align: left; font-weight: bold; }
        fieldset { border: 1px solid #d1d5db; padding: 1rem; border-radius: 0.5rem; margin-bottom: 1.5rem; }
        legend { font-size: 1.25rem; font-weight: 600; padding: 0 0.5rem; color: #1f2937; }
        textarea { min-height: 200px; resize: vertical; }
        #htmlPreview { background-color: #fffccc; }

        /* --- Tooltip Styles --- */
        .tooltip-container {
            position: relative;
            display: inline-flex;
            align-items: center;
        }

        .tooltip-trigger {
            cursor: pointer;
            margin-left: 8px;
            color: #6b7280;
            border: 1px solid #d1d5db;
            border-radius: 9999px;
            width: 20px;
            height: 20px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 12px;
            transition: all 0.2s ease-in-out;
        }

        .tooltip-trigger:hover {
            background-color: #e5e7eb;
            color: #1f2937;
        }

        .tooltip {
            position: absolute;
            bottom: 125%; /* Position above the trigger */
            left: 50%;
            transform: translateX(-50%);
            background-color: #1f2937;
            color: #ffffff;
            padding: 12px;
            border-radius: 8px;
            width: 300px;
            z-index: 10;
            visibility: hidden;
            opacity: 0;
            transition: opacity 0.2s, visibility 0.2s;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            font-size: 14px;
            line-height: 1.6;
        }
        
        .tooltip::after {
            content: "";
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: #1f2937 transparent transparent transparent;
        }

        .tooltip-container:hover .tooltip {
            visibility: visible;
            opacity: 1;
        }
        .tooltip-pro { color: #86efac; font-weight: bold; }
        .tooltip-con { color: #fca5a5; font-weight: bold; }
    </style>
</head>
<body class="bg-gray-100">
    <div class="container mx-auto p-4 md:p-8 my-8 bg-white rounded-lg shadow-2xl">
        <h1 class="text-3xl md:text-4xl font-bold text-center mb-6 text-gray-800">Waterverri's Advanced Text Watermarking Tool</h1>
        <p class="text-center text-gray-600 mb-8">Versi definitif dengan logika backtracking acak yang benar dan tag orisinal yang terjaga.</p>

        <div id="config-container" class="mb-8">
            <fieldset>
                <legend>Konfigurasi</legend>
                <div id="controls-grid" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-x-8 gap-y-6">
                    </div>
            </fieldset>
             <fieldset>
                <legend>Obfuscation Tingkat Lanjut</legend>
                 <div id="advanced-controls-grid" class="grid grid-cols-1 md:grid-cols-2 gap-x-8 gap-y-6">
                     </div>
            </fieldset>
        </div>

        <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
            <div>
                <label for="originalText" class="block text-sm font-medium text-gray-700 mb-1">Teks Asli (dengan BBCode):</label>
                <textarea id="originalText" class="shadow-sm focus:ring-indigo-500 focus:border-indigo-500 block w-full sm:text-sm border-gray-300 rounded-md p-2 bg-gray-50" placeholder="[b]Contoh:[/b] Masukkan teks [i]BBCode[/i] Anda dengan [size=7]ukuran kustom[/size] di sini."></textarea>
            </div>
            <div>
                <label for="customPhrases" class="block text-sm font-medium text-gray-700 mb-1">Frasa Tak Terlihat Kustom (satu per baris):</label>
                <textarea id="customPhrases" class="shadow-sm focus:ring-indigo-500 focus:border-indigo-500 block w-full sm:text-sm border-gray-300 rounded-md p-2 bg-gray-50" placeholder="Frasa kustom.&#10;Pesan rahasia lainnya."></textarea>
            </div>
        </div>

        <div class="text-center mb-8">
            <button id="applyWatermarkBtn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg shadow-lg transition duration-300 ease-in-out transform hover:scale-105">
                Terapkan Watermark
            </button>
        </div>

        <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
            <div>
                <h2 class="text-xl font-semibold text-gray-700 mb-2">Pratinjau HTML Watermark:</h2>
                <div id="htmlPreview" class="preview-area p-3 border border-gray-300 rounded-md min-h-[150px] whitespace-pre-wrap break-words text-base">
                    Pratinjau akan muncul di sini...
                </div>
            </div>
            <div>
                <h2 class="text-xl font-semibold text-gray-700 mb-2">Output BBCode Watermark:</h2>
                <textarea id="bbcodeOutput" rows="10" readonly class="shadow-sm block w-full sm:text-sm border-gray-300 rounded-md p-2 bg-gray-100 cursor-copy" placeholder="BBCode yang di-watermark akan muncul di sini..."></textarea>
                <button id="copyBbcodeBtn" class="mt-2 bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg shadow text-sm">
                    Salin BBCode
                </button>
                <span id="copyStatus" class="ml-2 text-sm text-green-600 font-semibold"></span>
            </div>
        </div>
    </div>

    <script>
        // --- CONFIGURATION & UI SETUP ---
        const DEFAULT_CONFIG = {
            probSpaceToInvisible: { value: 0.2, min: 0, max: 1, step: 0.01, label: "Prob. Penggantian Spasi", help: "Probabilitas sebuah spasi akan diganti dengan karakter tak terlihat.<br><br><span class='tooltip-pro'>Pro:</span> Nilai tinggi membuat teks sangat sulit dibersihkan otomatis.<br><span class='tooltip-con'>Kontra:</span> Nilai tinggi menaikkan jumlah karakter secara signifikan." },
            probNewlinePara: { value: 0.2, min: 0, max: 1, step: 0.01, label: "Prob. Sisipan di Baris Baru", help: "Probabilitas sebuah paragraf tak terlihat akan disisipkan setiap kali Anda menekan Enter.<br><br><span class='tooltip-pro'>Pro:</span> Menambah banyak 'sampah' tak terlihat di antara paragraf.<br><span class='tooltip-con'>Kontra:</span> Meningkatkan jumlah karakter secara drastis." },
            probEndPara: { value: 0.8, min: 0, max: 1, step: 0.01, label: "Prob. Sisipan di Akhir Teks", help: "Probabilitas sebuah paragraf tak terlihat akan ditambahkan di paling akhir seluruh naskah.<br><br><span class='tooltip-pro'>Pro:</span> Menjamin adanya watermark di akhir cerita.<br><span class='tooltip-con'>Kontra:</span> Sedikit menambah jumlah karakter." },
            textColorVariation: { value: 10, min: 0, max: 50, step: 1, label: "Variasi Warna Teks Terlihat", help: "Mengatur seberapa jauh variasi warna teks dari hitam murni.<br><br><span class='tooltip-pro'>Pro:</span> Nilai tinggi membuat teks lebih sulit diseleksi secara manual.<br><span class='tooltip-con'>Kontra:</span> Jika terlalu tinggi, teks bisa terlihat berwarna-warni dan tidak alami." },
            idealLineLengthMultiplier: { value: 1.0, min: 0.1, max: 2.0, step: 0.1, label: "Pengali Panjang Baris Ideal", help: "Mengatur target panjang untuk setiap baris (termasuk yang kosong). 1.0 = panjang rata-rata.<br><br><span class='tooltip-pro'>Pro:</span> Nilai tinggi membuat semua baris terlihat sama padat, membingungkan bot.<br><span class='tooltip-con'>Kontra:</span> Meningkatkan jumlah karakter secara signifikan." },
            useSpanObfuscation: { value: true, label: "Aktifkan Obfuscation Span Hirarkis", help: "Mengaktifkan metode obfuscation paling canggih, menggunakan tumpukan tag `[color]` dan `[size]` yang acak.<br><br><span class='tooltip-pro'>Pro:</span> Pertahanan terkuat. Sangat sulit dibersihkan otomatis.<br><span class='tooltip-con'>Kontra:</span> Menghasilkan BBCode yang paling panjang dan kompleks." },
            spanObfuscationDepth: { value: 3, min: 1, max: 8, step: 1, label: "Maks. Kedalaman Obfuscation Span", help: "Mengatur kedalaman maksimum dari struktur pohon span.<br><br><span class='tooltip-pro'>Pro:</span> Nilai tinggi membuat struktur pohon lebih dalam dan kompleks.<br><span class='tooltip-con'>Kontra:</span> Meningkatkan jumlah karakter secara eksponensial." },
            probRedundantColor: { value: 0.5, min: 0, max: 1, step: 0.01, label: "Prob. Warna Redundan", help: "(Hanya aktif jika Obfuscation Hirarkis diaktifkan). Saat sebuah node daun seharusnya sudah memiliki visibilitas yang benar, ini adalah probabilitas untuk tetap memakai tag `[color]` (menambah noise) daripada tag `[size]` (memaksa backtracking).<br><br><span class='tooltip-pro'>Pro:</span> Menambah noise, membuat pola lebih sulit ditebak.<br><span class='tooltip-con'>Kontra:</span> Sedikit mengurangi efektivitas paksaan backtracking." },
            useOverlappingColors: { value: true, label: "Aktifkan Warna Anti-Regex Bertumpuk", help: "Mengubah palet warna sehingga teks terlihat dan tak terlihat bisa memiliki awalan HEX yang sama (misal #A...).<br><br><span class='tooltip-pro'>Pro:</span> Membuat pembersihan dengan regex sederhana menjadi hampir mustahil.<br><span class='tooltip-con'>Kontra:</span> Estetika teks mungkin sedikit terganggu (tidak murni hitam)."},
        };

        const LIVE_CONFIG = {};
        const STATIC_CONFIG = {
            BACKGROUND_COLOR: { r: 255, g: 252, b: 204 },
            TEXT_COLOR_BASE: { r: 28, g: 30, b: 33 },
            DEFAULT_INVISIBLE_PHRASES: ["Konten ini dirancang agar sulit dideteksi.", "Watermarking membantu melindungi karya asli.", "Rubah cokelat cepat melompati anjing malas."],
            LOCALSTORAGE_KEY_CUSTOM_PHRASES: 'phpbbWatermarkerCustomPhrases',
            MINIMAL_DEFAULT_INVISIBLE_CHAR: "Â·",
            DEBOUNCE_DELAY: 500, // Added debounce delay
        };

        // --- UI & HELPERS ---
        function bindUI() {
            const controlsGrid = document.getElementById('controls-grid');
            const advancedGrid = document.getElementById('advanced-controls-grid');
            Object.keys(DEFAULT_CONFIG).forEach(key => {
                const setting = DEFAULT_CONFIG[key];
                const isAdvanced = key.includes('use') || key.includes('Depth') || key.includes('probRedundant') || key.includes('Multiplier');
                const targetGrid = isAdvanced ? advancedGrid : controlsGrid;
                
                const controlWrapper = document.createElement('div');
                controlWrapper.className = 'flex items-center justify-between';

                const labelContainer = document.createElement('div');
                labelContainer.className = 'tooltip-container';

                const label = document.createElement('label');
                label.htmlFor = key;
                label.textContent = setting.label;
                label.className = 'text-sm font-medium text-gray-700';
                
                const tooltipTrigger = document.createElement('span');
                tooltipTrigger.className = 'tooltip-trigger';
                tooltipTrigger.textContent = '?';

                const tooltip = document.createElement('div');
                tooltip.className = 'tooltip';
                tooltip.innerHTML = setting.help;

                labelContainer.appendChild(label);
                labelContainer.appendChild(tooltipTrigger);
                labelContainer.appendChild(tooltip);

                controlWrapper.appendChild(labelContainer);

                if (typeof setting.value === 'boolean') {
                    const control = document.createElement('input');
                    control.type = 'checkbox';
                    control.id = key;
                    control.checked = setting.value;
                    control.className = 'h-5 w-5 text-indigo-600 focus:ring-indigo-500 border-gray-300 rounded';
                    controlWrapper.appendChild(control);
                } else {
                    const control = document.createElement('input');
                    control.type = 'range';
                    control.id = key;
                    control.min = setting.min;
                    control.max = setting.max;
                    control.step = setting.step;
                    control.value = setting.value;
                    control.className = 'w-1/2 h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer';
                    const valueSpan = document.createElement('span');
                    valueSpan.id = `${key}-value`;
                    valueSpan.textContent = setting.value.toFixed(1);
                    valueSpan.className = 'range-value text-indigo-700';
                    const innerWrapper = document.createElement('div');
                    innerWrapper.className = 'flex items-center gap-2';
                    innerWrapper.appendChild(control);
                    innerWrapper.appendChild(valueSpan);
                    controlWrapper.appendChild(innerWrapper);
                }
                targetGrid.appendChild(controlWrapper);
            });
            updateConfigFromUI();
            document.querySelectorAll('#config-container input').forEach(input => {
                input.addEventListener('input', () => {
                    updateConfigFromUI();
                    if (input.type === 'range') {
                         document.getElementById(`${input.id}-value`).textContent = parseFloat(input.value).toFixed(1);
                    }
                });
            });
        }
        function updateConfigFromUI() {
            Object.keys(DEFAULT_CONFIG).forEach(key => {
                const el = document.getElementById(key);
                if (el) LIVE_CONFIG[key] = (el.type === 'checkbox') ? el.checked : parseFloat(el.value);
            });
        }
        function _getRandomInt(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }
        function _getRandomElement(arr) { return arr.length > 0 ? arr[Math.floor(Math.random() * arr.length)] : ''; }
        function _rgbToHex(r, g, b) { return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).toUpperCase(); }
        function escapeHtml(unsafe) { return unsafe.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;"); }
        function getTextContentLength(bbcodeString) { return (bbcodeString || '').replace(/\[[^\]]+\]/g, '').length; }
        
        // --- COLOR GENERATION ---
        function getVisibleColorHex() {
            if (LIVE_CONFIG.useOverlappingColors) {
                const r = _getRandomInt(100, 190); const g = _getRandomInt(0, 80); const b = _getRandomInt(0, 80);
                return _rgbToHex(r, g, b);
            }
            const base = STATIC_CONFIG.TEXT_COLOR_BASE;
            const variation = LIVE_CONFIG.textColorVariation;
            const r = Math.max(0, Math.min(255, base.r + _getRandomInt(-variation, variation)));
            const g = Math.max(0, Math.min(255, base.g + _getRandomInt(-variation, variation)));
            const b = Math.max(0, Math.min(255, base.b + _getRandomInt(-variation, variation)));
            return _rgbToHex(r, g, b);
        }

        function getInvisibleColorHex() {
            if (LIVE_CONFIG.useOverlappingColors) {
                const r = _getRandomInt(160, 255); const g = _getRandomInt(240, 255); const b = _getRandomInt(240, 255);
                return _rgbToHex(r, g, b);
            }
            const base = STATIC_CONFIG.BACKGROUND_COLOR;
            const r = Math.max(0, Math.min(255, base.r + _getRandomInt(-1, 1)));
            const g = Math.max(0, Math.min(255, base.g + _getRandomInt(-1, 1)));
            const b = Math.max(0, Math.min(255, base.b + _getRandomInt(-1, 1)));
            return _rgbToHex(r, g, b);
        }

        // --- ADVANCED OBFUSCATION (Corrected Logic v16) ---
        function generateHierarchicalSpans(text, shouldBeVisible, depth, parentMakesVisible) {
            // This is a LEAF node.
            if (depth <= 0 || text.length < 2) {
                let useSizeTag = false;
                // Golden Rule: Check if we are ALLOWED to use a size tag.
                if (shouldBeVisible === parentMakesVisible) {
                    // If allowed, RANDOMLY choose based on the probability.
                    if (Math.random() > LIVE_CONFIG.probRedundantColor) {
                        useSizeTag = true;
                    }
                }

                if (useSizeTag) {
                    return `<span class="size-node">${escapeHtml(text)}</span>`;
                } else {
                    // Otherwise, we MUST use a color tag to ensure correct visibility.
                    const color = shouldBeVisible ? getVisibleColorHex() : getInvisibleColorHex();
                    return `<span style="color:${color};">${escapeHtml(text)}</span>`;
                }
            }

            // This is an INTERMEDIARY node.
            // It has the UTMOST FREEDOM to decide its type.
            const nodeType = _getRandomElement(['size', 'colorShow', 'colorHide']);
            
            const mid = Math.floor(text.length / 2);
            const part1 = text.substring(0, mid);
            const part2 = text.substring(mid);

            let newParentMakesVisible;
            if (nodeType === 'size') {
                // This node is transparent. It passes its parent's visibility context down.
                newParentMakesVisible = parentMakesVisible;
                const child1 = generateHierarchicalSpans(part1, shouldBeVisible, depth - 1, newParentMakesVisible);
                const child2 = generateHierarchicalSpans(part2, shouldBeVisible, depth - 1, newParentMakesVisible);
                return `<span class="size-node">${child1}${child2}</span>`;
            } else { // nodeType is 'colorShow' or 'colorHide'
                // This node sets a NEW visibility context for its children.
                newParentMakesVisible = (nodeType === 'colorShow');
                
                const child1 = generateHierarchicalSpans(part1, shouldBeVisible, depth - 1, newParentMakesVisible);
                const child2 = generateHierarchicalSpans(part2, shouldBeVisible, depth - 1, newParentMakesVisible);

                const color = newParentMakesVisible ? getVisibleColorHex() : getInvisibleColorHex();
                return `<span style="color:${color};">${child1}${child2}</span>`;
            }
        }


        // --- CORE LOGIC ---
        function processTextNode(textNodeContent) {
            if (LIVE_CONFIG.useSpanObfuscation) {
                const maxDepth = LIVE_CONFIG.spanObfuscationDepth;
                const randomDepth = _getRandomInt(1, maxDepth);
                return generateHierarchicalSpans(textNodeContent, true, randomDepth, true);
            }
            
            let processedHtml = "";
            const sentences = textNodeContent.match(/[^.!?]+(?:[.!?]+|$)/g) || [textNodeContent];
            sentences.forEach(sentence => {
                if (!sentence.trim()) { processedHtml += sentence; return; }
                let sentenceInnerHtml = "";
                const wordsAndSpaces = sentence.split(/(\s+)/);
                wordsAndSpaces.forEach(segment => {
                    if (segment.match(/^\s+$/)) {
                        for (let char of segment) {
                            if (char === ' ' && Math.random() < LIVE_CONFIG.probSpaceToInvisible) {
                                if (LIVE_CONFIG.useSpanObfuscation) {
                                    const invisibleChar = _getRandomElement('abcdefghijklmnopqrstuvwxyz'.split(''));
                                    const maxDepth = LIVE_CONFIG.spanObfuscationDepth;
                                    const randomDepth = _getRandomInt(1, maxDepth);
                                    sentenceInnerHtml += generateHierarchicalSpans(invisibleChar, false, randomDepth, true);
                                } else {
                                    const invisibleChar = _getRandomElement('abcdefghijklmnopqrstuvwxyz'.split(''));
                                    sentenceInnerHtml += `<span style="color:${getInvisibleColorHex()};">${invisibleChar}</span>`;
                                }
                            } else {
                                sentenceInnerHtml += escapeHtml(char);
                            }
                        }
                    } else if (segment.length > 0) {
                        sentenceInnerHtml += escapeHtml(segment);
                    }
                });
                processedHtml += `<span style="color:${getVisibleColorHex()};">${sentenceInnerHtml}</span>`;
            });
            return processedHtml;
        }

        function generateInvisibleParagraphHtml() {
            const customPhrases = document.getElementById('customPhrases').value.split('\n').map(p => p.trim()).filter(Boolean);
            const phraseSource = customPhrases.length > 0 ? customPhrases : STATIC_CONFIG.DEFAULT_INVISIBLE_PHRASES;
            if (phraseSource.length === 0) return "";
            const phrase = _getRandomElement(phraseSource);
            if (!phrase) return "";

            if (LIVE_CONFIG.useSpanObfuscation) {
                const maxDepth = LIVE_CONFIG.spanObfuscationDepth;
                const randomDepth = _getRandomInt(1, maxDepth);
                return generateHierarchicalSpans(phrase, false, randomDepth, true);
            }
            return `<span style="display:block;height:0;overflow:hidden;line-height:0;"><span style="color:${getInvisibleColorHex()};">${escapeHtml(phrase)}</span></span>`;
        }
        
        // --- MAIN APPLICATION FLOW (Corrected for Newlines) ---
        function applyWatermark() {
            let originalBbcode = document.getElementById('originalText').value;
            const originalSizeTags = new Map();
            let placeholderIndex = 0;
            
            originalBbcode = originalBbcode.replace(/\[size=[\d]+\][\s\S]*?\[\/size\]/gi, (match) => {
                const placeholder = `__SIZE_PLACEHOLDER_${placeholderIndex}__`;
                originalSizeTags.set(placeholder, match);
                placeholderIndex++;
                return placeholder;
            });

            const originalLines = originalBbcode.split('\n');
            let totalTextContentLength = 0;
            let nonEmptyLinesCount = 0;
            originalLines.forEach(line => {
                const textLength = getTextContentLength(line);
                if (textLength > 0) {
                    totalTextContentLength += textLength;
                    nonEmptyLinesCount++;
                }
            });
            const idealTextContentLength = ((nonEmptyLinesCount > 0) ? Math.round(totalTextContentLength / nonEmptyLinesCount) : 30) * LIVE_CONFIG.idealLineLengthMultiplier;
            
            const processedLines = originalLines.map(line => {
                let processedLine = "";
                const parts = line.split(/(\[.+?\])/g).filter(Boolean); // Split by tags, but not newlines
                parts.forEach(part => {
                     if (part.match(/^__/)) { // Placeholder for original size tag
                        processedLine += part;
                    } else if (part.match(/^\[.+?\]$/)) { // Other BBCode tag
                        processedLine += part;
                    } else { // It's a text segment
                        processedLine += htmlToBbcode(processTextNode(part));
                    }
                });

                // Probabilistic insertion for non-empty lines that aren't just whitespace
                if(line.trim() && Math.random() < LIVE_CONFIG.probNewlinePara) {
                    processedLine += htmlToBbcode(generateInvisibleParagraphHtml());
                }

                // Deterministic padding for all lines
                let currentLength = getTextContentLength(processedLine);
                let safetyBreak = 0;
                while (currentLength < idealTextContentLength && safetyBreak < 50) {
                    const paddingHtml = generateInvisibleParagraphHtml();
                    if (!paddingHtml) break;
                    const paddingBbcode = htmlToBbcode(paddingHtml);
                    processedLine += paddingBbcode;
                    currentLength += getTextContentLength(paddingBbcode);
                    if (getTextContentLength(paddingBbcode) === 0) {
                         const minimalPadding = `[color=${getInvisibleColorHex()}]${STATIC_CONFIG.MINIMAL_DEFAULT_INVISIBLE_CHAR}[/color]`;
                         processedLine += minimalPadding;
                         currentLength = getTextContentLength(processedLine);
                         if (getTextContentLength(minimalPadding) === 0) break;
                    }
                    safetyBreak++;
                }
                return processedLine;
            });
            
            // Add end-of-text invisible paragraph if needed
            if (!originalBbcode.trim().endsWith('\n') && originalBbcode.trim().length > 0 && Math.random() < LIVE_CONFIG.probEndPara) {
                 processedLines[processedLines.length - 1] += htmlToBbcode(generateInvisibleParagraphHtml());
            }

            let finalBbcode = processedLines.join('\n');
            
            // Restore original [size] tags
            originalSizeTags.forEach((value, key) => {
                finalBbcode = finalBbcode.replace(new RegExp(key, 'g'), value);
            });

            document.getElementById('htmlPreview').innerHTML = bbcodeToHtml(finalBbcode);
            document.getElementById('bbcodeOutput').value = finalBbcode;
            document.getElementById('copyStatus').textContent = '';
        }
        
        // --- HTML <-> BBCode CONVERSION ---
        function htmlToBbcode(htmlString) {
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = htmlString;
            return convertNodeToBbcode(tempDiv);
        }

        function convertNodeToBbcode(node) {
            let bbcode = "";
            node.childNodes.forEach(child => {
                if (child.nodeType === Node.TEXT_NODE) {
                    bbcode += child.textContent;
                } else if (child.nodeType === Node.ELEMENT_NODE && child.nodeName === 'SPAN') {
                    if (child.classList.contains('size-node')) {
                        bbcode += `[size=4]${convertNodeToBbcode(child)}[/size]`;
                    } else if (child.style.color) {
                         try {
                            const hexColor = _rgbToHex(...child.style.color.match(/\d+/g).map(Number));
                            bbcode += `[color=${hexColor}]${convertNodeToBbcode(child)}[/color]`;
                        } catch (e) { 
                            bbcode += convertNodeToBbcode(child);
                        }
                    } else {
                        bbcode += convertNodeToBbcode(child);
                    }
                } else if (child.nodeType === Node.ELEMENT_NODE) {
                    bbcode += convertNodeToBbcode(child);
                }
            });
            return bbcode;
        }

        function bbcodeToHtml(bbcode) {
             let html = escapeHtml(bbcode);
            html = html.replace(/\[color=(#[0-9A-F]{6})\]([\s\S]*?)\[\/color\]/gi, '<span style="color:$1">$2</span>');
            html = html.replace(/\[size=4\]([\s\S]*?)\[\/size\]/gi, '$1'); 
            html = html.replace(/\n/g, '<br>');
            return html;
        }

        // --- EVENT LISTENERS & LOAD ---
        document.getElementById('applyWatermarkBtn').addEventListener('click', applyWatermark);
        
        document.getElementById('copyBbcodeBtn').addEventListener('click', () => {
            const bbcodeOutput = document.getElementById('bbcodeOutput');
            const copyStatus = document.getElementById('copyStatus');
            bbcodeOutput.select();
            bbcodeOutput.setSelectionRange(0, 99999); // For mobile devices

            try {
                const successful = document.execCommand('copy');
                if (successful) {
                    copyStatus.textContent = 'Berhasil disalin!';
                } else {
                    copyStatus.textContent = 'Gagal menyalin.';
                }
            } catch (err) {
                copyStatus.textContent = 'Gagal menyalin (error).';
                console.error('Fallback: Oops, unable to copy', err);
            }
            window.getSelection().removeAllRanges(); // Deselect
        });

        // --- DEBOUNCED LOCALSTORAGE (FIXED) ---
        let debounceTimeout;
        const customPhrasesTextarea = document.getElementById('customPhrases');

        function saveCustomPhrases() {
            const phrases = customPhrasesTextarea.value.split('\n').map(p => p.trim()).filter(p => p.length > 0);
            localStorage.setItem(STATIC_CONFIG.LOCALSTORAGE_KEY_CUSTOM_PHRASES, JSON.stringify(phrases));
        }

        function loadCustomPhrases() {
            const savedPhrases = localStorage.getItem(STATIC_CONFIG.LOCALSTORAGE_KEY_CUSTOM_PHRASES);
            if (savedPhrases) {
                try {
                    const phrasesArray = JSON.parse(savedPhrases);
                    if (Array.isArray(phrasesArray)) {
                        customPhrasesTextarea.value = phrasesArray.join('\n');
                    }
                } catch (e) {
                    console.error("Error parsing saved custom phrases:", e);
                    // If parsing fails, it might be the old raw string format. Try to load it directly.
                    if (typeof savedPhrases === 'string') {
                        customPhrasesTextarea.value = savedPhrases;
                    } else {
                       localStorage.removeItem(STATIC_CONFIG.LOCALSTORAGE_KEY_CUSTOM_PHRASES);
                    }
                }
            }
        }

        customPhrasesTextarea.addEventListener('input', () => {
            clearTimeout(debounceTimeout);
            debounceTimeout = setTimeout(saveCustomPhrases, STATIC_CONFIG.DEBOUNCE_DELAY);
        });

        window.onload = () => {
            bindUI();
            loadCustomPhrases();
        };
    </script>
</body>
</html>
