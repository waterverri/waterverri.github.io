<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PHPBB Text Watermarker</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #fffccc; 
            color: #1c1e21; 
        }
        .container {
            max-width: 1000px;
            margin: 20px auto;
            padding: 20px;
            background-color: #ffffff; 
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1), 0 8px 16px rgba(0,0,0,0.1);
        }
        textarea {
            width: 100%;
            padding: 10px;
            border: 1px solid #ccd0d5;
            border-radius: 6px;
            font-family: monospace;
            font-size: 14px;
            line-height: 1.5;
            min-height: 150px;
            resize: vertical;
            background-color: #f5f6f7;
        }
        button {
            background-color: #1877f2; 
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            font-size: 16px;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        button:hover {
            background-color: #166fe5;
        }
        h1, h2, h3 {
            color: #050505; 
            margin-bottom: 0.5em;
        }
        h1 { font-size: 1.8em; margin-bottom: 1em; text-align: center; }
        h2 { font-size: 1.4em; margin-top: 1.5em; border-bottom: 1px solid #e0e0e0; padding-bottom: 0.3em;}
        .preview-area {
            border: 1px solid #ccd0d5;
            padding: 10px;
            min-height: 100px;
            background-color: #fffccc; 
            border-radius: 6px;
            white-space: pre-wrap; 
            word-wrap: break-word; 
            font-family: Arial, sans-serif; 
            font-size: 16px; 
            line-height: 1.6;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #333;
        }

        /* --- DEBUGGING STYLES --- */
        /* Uncomment to make "invisible" elements visible for debugging in HTML Preview */
        
        /* .invisible-space-char {
            background-color: yellow !important;
            color: red !important;
            outline: 1px solid orange !important;
            font-size: 16px !important; 
        }
        .invisible-paragraph-container {
            background-color: lightblue !important;
            color: navy !important; 
            outline: 1px solid blue !important;
            height: auto !important; 
            line-height: normal !important; 
            overflow: visible !important; 
        }
        .invisible-fragment {
            background-color: lightgreen !important;
            color: darkmagenta !important;
            outline: 1px solid green !important;
        }
        .word-fragment {
            outline: 1px dashed magenta;
        }
        */

    </style>
</head>
<body class="bg-[#fffccc]">
    <div class="container mx-auto p-6 bg-white rounded-lg shadow-xl">
        <h1 class="text-3xl font-bold text-center mb-8 text-gray-800">Text Watermarking Tool for BBCode</h1>

        <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
            <div>
                <label for="originalText" class="block text-sm font-medium text-gray-700 mb-1">Original Text (with BBCode):</label>
                <textarea id="originalText" rows="10" class="shadow-sm focus:ring-indigo-500 focus:border-indigo-500 block w-full sm:text-sm border-gray-300 rounded-md p-2 bg-gray-50" placeholder="[b]Example:[/b] Enter your [i]BBCode[/i] text here.&#10;It can span multiple lines.&#10;&#10;Including paragraph breaks."></textarea>
            </div>
            <div>
                <label for="customPhrases" class="block text-sm font-medium text-gray-700 mb-1">Custom Invisible Paragraph/Sentence Phrases (one per line):</label>
                <textarea id="customPhrases" rows="10" class="shadow-sm focus:ring-indigo-500 focus:border-indigo-500 block w-full sm:text-sm border-gray-300 rounded-md p-2 bg-gray-50" placeholder="A custom phrase.&#10;Another secret message.&#10;This adds unique watermarks."></textarea>
            </div>
        </div>

        <div class="text-center mb-8">
            <button id="applyWatermarkBtn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg shadow-md transition duration-150 ease-in-out">
                Apply Watermark
            </button>
        </div>

        <div class="mb-6">
            <h2 class="text-xl font-semibold text-gray-700 mb-2">Watermarked HTML Preview:</h2>
            <div id="htmlPreview" class="preview-area p-3 border border-gray-300 rounded-md min-h-[100px] whitespace-pre-wrap break-words">
                Preview will appear here...
            </div>
        </div>

        <div>
            <h2 class="text-xl font-semibold text-gray-700 mb-2">Watermarked BBCode Output (Forums):</h2>
            <textarea id="bbcodeOutput" rows="10" readonly class="shadow-sm block w-full sm:text-sm border-gray-300 rounded-md p-2 bg-gray-50 cursor-not-allowed" placeholder="Watermarked BBCode will appear here..."></textarea>
            <button id="copyBbcodeBtn" class="mt-2 bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg shadow text-sm">
                Copy BBCode
            </button>
            <span id="copyStatus" class="ml-2 text-sm text-green-600"></span>
        </div>

    </div>

    <script>
        const CONFIG = {
            BACKGROUND_COLOR: { r: 255, g: 252, b: 204 }, // #fffccc
            TEXT_COLOR_BASE: { r: 28, g: 30, b: 33 },   
            COLOR_VARIATION: 1, 
            TEXT_COLOR_VARIATION: 10, 

            PROB_SPACE_TO_INVISIBLE_CHAR: 0.3, 
            PROB_NEWLINE_TO_INVISIBLE_PARA: 0.6, 
            PROB_ADD_END_PARA_INVISIBLE_SENTENCE: 0.8, 

            PROB_VISIBLE_SPAN_PREFIX_INVISIBLE: 0.0, 
            PROB_VISIBLE_SPAN_SUFFIX_INVISIBLE: 0.0, 

            DEFAULT_INVISIBLE_PARAGRAPH_CONTENT: [
                "This content is intended to be difficult to detect.",
                "Watermarking helps protect original work from unauthorized copying.",
                "The quick brown fox jumps over the lazy dog.", "Lorem ipsum dolor sit amet.",
                "Consectetur adipiscing elit sed do eiusmod tempor incididunt.",
                "Ut labore et dolore magna aliqua ut enim ad minim veniam.",
                "Quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.",
                "Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur.",
                "Excepteur sint occaecat cupidatat non proident sunt in culpa qui officia deserunt mollit anim id est laborum."
            ],
            MINIMAL_DEFAULT_INVISIBLE_CHAR: "Â·", 
            MICRO_INVISIBLE_CHARS: 'abcdefghijklmnopqrstuvwxyz'.split(''),
            LOCALSTORAGE_KEY_CUSTOM_PHRASES: 'phpbbWatermarkerCustomPhrases',
            DEBOUNCE_DELAY: 500,
        };

        // --- Helper Functions ---
        function _getRandomInt(min, max) {
            if (max < min) max = min;
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        function _getRandomElement(arr) {
            if (!arr || arr.length === 0) return ''; 
            return arr[Math.floor(Math.random() * arr.length)];
        }

        function _rgbToHex(r, g, b) {
            return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).toUpperCase();
        }

        function _getDynamicColor(baseColor, variation) {
            const r = Math.max(0, Math.min(255, baseColor.r + _getRandomInt(-variation, variation)));
            const g = Math.max(0, Math.min(255, baseColor.g + _getRandomInt(-variation, variation)));
            const b = Math.max(0, Math.min(255, baseColor.b + _getRandomInt(-variation, variation)));
            return { r, g, b };
        }

        function getInvisibleTextColor() {
            const color = _getDynamicColor(CONFIG.BACKGROUND_COLOR, CONFIG.COLOR_VARIATION);
            return `rgb(${color.r},${color.g},${color.b})`;
        }
        function getInvisibleTextColorHex() {
            const color = _getDynamicColor(CONFIG.BACKGROUND_COLOR, CONFIG.COLOR_VARIATION);
            return _rgbToHex(color.r, color.g, color.b);
        }

        function getVisibleTextColor() {
            const color = _getDynamicColor(CONFIG.TEXT_COLOR_BASE, CONFIG.TEXT_COLOR_VARIATION);
            return `rgb(${color.r},${color.g},${color.b})`;
        }
        function getVisibleTextColorHex() {
             const color = _getDynamicColor(CONFIG.TEXT_COLOR_BASE, CONFIG.TEXT_COLOR_VARIATION);
            return _rgbToHex(color.r, color.g, color.b);
        }

        function escapeHtml(unsafe) {
            if (unsafe === null || unsafe === undefined) return '';
            return unsafe
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;")
                .replace(/"/g, "&quot;")
                .replace(/'/g, "&#039;");
        }

        // NEW Helper function to get text content length by stripping BBCode
        function getTextContentLength(bbcodeString) {
            if (bbcodeString === null || bbcodeString === undefined) return 0;
            // This regex aims to remove [tag=value], [tag], and [/tag] style BBCode.
            // It's a simplification and might not cover all complex/nested BBCode perfectly,
            // but should be sufficient for length approximation.
            const textOnly = bbcodeString.replace(/\[[^\]]+\]/g, '');
            return textOnly.length;
        }
        
        // --- Fragmentation Functions ---

        function _generateFragmentedSpansHtmlInvisible(text) {
            let html = "";
            const minFragmentLength = 1;
            const maxFragmentLength = 3; 
            let i = 0;
            while (i < text.length) {
                const fragmentLength = _getRandomInt(minFragmentLength, Math.min(maxFragmentLength, text.length - i));
                const fragment = text.substring(i, i + fragmentLength);
                if (fragment.length === 0) break; 
                html += `<span class="invisible-fragment" style="color:${getInvisibleTextColor()};">${escapeHtml(fragment)}</span>`;
                i += fragmentLength;
            }
            return html;
        }

        function _generateFragmentedSpansHtmlVisible(text) {
            let html = "";
            let i = 0;
            const baseStyle = ""; 

            while (i < text.length) {
                const fragmentLength = _getRandomInt(1, 2); 
                const fragment = text.substring(i, Math.min(i + fragmentLength, text.length));
                if (fragment.length === 0) break; 

                html += `<span class="word-fragment" style="color:${getVisibleTextColor()}; ${baseStyle}">${escapeHtml(fragment)}</span>`;
                i += fragment.length;
            }
            return html;
        }


        // --- LocalStorage for Custom Phrases ---
        let debounceTimeout;
        const customPhrasesTextarea = document.getElementById('customPhrases');

        function saveCustomPhrases() {
            const phrases = customPhrasesTextarea.value.split('\n').map(p => p.trim()).filter(p => p.length > 0);
            localStorage.setItem(CONFIG.LOCALSTORAGE_KEY_CUSTOM_PHRASES, JSON.stringify(phrases));
        }

        function loadCustomPhrases() {
            const savedPhrases = localStorage.getItem(CONFIG.LOCALSTORAGE_KEY_CUSTOM_PHRASES);
            if (savedPhrases) {
                try {
                    const phrasesArray = JSON.parse(savedPhrases);
                    customPhrasesTextarea.value = phrasesArray.join('\n');
                } catch (e) {
                    console.error("Error parsing saved custom phrases:", e);
                    localStorage.removeItem(CONFIG.LOCALSTORAGE_KEY_CUSTOM_PHRASES);
                }
            }
        }

        customPhrasesTextarea.addEventListener('input', () => {
            clearTimeout(debounceTimeout);
            debounceTimeout = setTimeout(saveCustomPhrases, CONFIG.DEBOUNCE_DELAY);
        });


        // --- Core Watermarking Logic ---
        function processTextNode(textNodeContent) {
            let processedHtml = "";
            const wordsAndSpaces = textNodeContent.split(/(\s+)/); 

            wordsAndSpaces.forEach(segment => {
                if (segment.match(/^\s+$/)) { 
                    for (let char of segment) { 
                        if (char === ' ' && Math.random() < CONFIG.PROB_SPACE_TO_INVISIBLE_CHAR) {
                            const invisibleChar = _getRandomElement(CONFIG.MICRO_INVISIBLE_CHARS);
                            processedHtml += `<span class="invisible-space-char" style="color:${getInvisibleTextColor()};">${escapeHtml(invisibleChar)}</span>`;
                        } else {
                            processedHtml += escapeHtml(char); 
                        }
                    }
                } else if (segment.length > 0) { 
                    processedHtml += _generateFragmentedSpansHtmlVisible(segment);
                }
            });
            return processedHtml;
        }

        function generateInvisibleParagraphHtml() {
            const customPhrases = customPhrasesTextarea.value.split('\n').map(p => p.trim()).filter(p => p.length > 0);
            const phraseSource = customPhrases.length > 0 ? customPhrases : CONFIG.DEFAULT_INVISIBLE_PARAGRAPH_CONTENT;
            if (phraseSource.length === 0 || phraseSource.every(p => p.length === 0) ) {
                return ""; 
            }

            const availablePhrases = phraseSource.filter(p => p.length > 0);
            if (availablePhrases.length === 0) {
                return "";
            }
            const phrase = _getRandomElement(availablePhrases); 
            
            const fragmentedContent = _generateFragmentedSpansHtmlInvisible(phrase); 
            return `<span class="invisible-paragraph-container" style="display:block; line-height:0.1px; height:0.1px; overflow:hidden;">${fragmentedContent}</span>`;
        }
        
        function applyWatermark() {
            console.log("--- applyWatermark START ---");
            const originalBbcode = document.getElementById('originalText').value;
            let processedHtmlContent = ""; 
            let intermediateBbcode = ""; 
            
            const originalLines = originalBbcode.split('\n');
            let maxOriginalTextContentLength = 0; // Changed variable name for clarity
            if (originalLines.length > 0) {
                // Calculate max length based on text content of original lines
                maxOriginalTextContentLength = originalLines.reduce((max, line) => Math.max(max, getTextContentLength(line)), 0);
            }
            // Ensure idealLineLength is at least a moderate value for text content
            const idealTextContentLineLength = Math.max(maxOriginalTextContentLength, 30); // Using 30 as a minimum for text content
            console.log(`Calculated idealTextContentLineLength: ${idealTextContentLineLength} (maxOriginalTextContent: ${maxOriginalTextContentLength})`);


            const parts = originalBbcode.split(/(\[[^\]]+\]|\[\/[^\]]+\]|\n)/g);
            let previousPartEndedInNewline = false; 

            parts.forEach((part, index) => {
                if (!part && part !== '\n') return; 

                if (part.match(/^\[[^\]]+\]$/) || part.match(/^\[\/[^\]]+\]$/)) { 
                    processedHtmlContent += escapeHtml(part); 
                    intermediateBbcode += part;
                    previousPartEndedInNewline = false; 
                } else if (part === '\n') { 
                    processedHtmlContent += '\n';
                    intermediateBbcode += '\n';

                    let canAddInvisibleParaAtThisNewline = true;
                    if (previousPartEndedInNewline) {
                        canAddInvisibleParaAtThisNewline = false;
                    }
                    if (index + 1 < parts.length && parts[index + 1] === '\n') {
                        canAddInvisibleParaAtThisNewline = false;
                    }

                    if (canAddInvisibleParaAtThisNewline && Math.random() < CONFIG.PROB_NEWLINE_TO_INVISIBLE_PARA) {
                        const invisibleHtml = generateInvisibleParagraphHtml();
                        if (invisibleHtml) { 
                           processedHtmlContent += invisibleHtml; 
                           intermediateBbcode += htmlToBbcode(invisibleHtml); 
                        }
                    }
                    previousPartEndedInNewline = true; 
                } else { 
                    const watermarkedTextHtml = processTextNode(part);
                    processedHtmlContent += watermarkedTextHtml;
                    intermediateBbcode += htmlToBbcode(watermarkedTextHtml);
                    previousPartEndedInNewline = false; 
                }
            });

            if (!originalBbcode.endsWith('\n') && Math.random() < CONFIG.PROB_ADD_END_PARA_INVISIBLE_SENTENCE) {
                const invisibleHtml = generateInvisibleParagraphHtml();
                 if (invisibleHtml) {
                    processedHtmlContent += invisibleHtml;
                    intermediateBbcode += htmlToBbcode(invisibleHtml);
                }
            }

            console.log("Intermediate BBCode before padding:\n", intermediateBbcode);
            // Pass the ideal TEXT CONTENT length
            const finalBbcode = padLinesToIdealLength(intermediateBbcode, idealTextContentLineLength); 

            document.getElementById('htmlPreview').innerHTML = processedHtmlContent;
            document.getElementById('bbcodeOutput').value = finalBbcode;
            document.getElementById('copyStatus').textContent = ''; 
            console.log("--- applyWatermark END ---");
        }

        function logPaddingMessage(message) { 
            console.log("  PADDING_LOG: " + message);
        }

        function padLinesToIdealLength(bbcodeString, idealTextContentLength) { // Parameter name changed
            logPaddingMessage(`--- padLinesToIdealLength START (ideal TEXT CONTENT length: ${idealTextContentLength}) ---`);
            const lines = bbcodeString.split('\n');
            const paddedLines = [];
            let lineIndex = 0;

            for (const line of lines) {
                lineIndex++;
                let currentLine = line;
                let currentTextContentLength = getTextContentLength(currentLine);
                logPaddingMessage(`\n[Line ${lineIndex} START] Original line: "${line}" (RawLength: ${line.length}, TextContentLength: ${currentTextContentLength})`);
                
                let loopCount = 0; 
                // Loop based on TEXT CONTENT length
                while (currentTextContentLength < idealTextContentLength) { 
                    loopCount++;
                    logPaddingMessage(`  [L${lineIndex} Loop ${loopCount}] Current TextContentLength: ${currentTextContentLength}, Ideal: ${idealTextContentLength}`);
                    
                    let paddingSegmentBbcode = "";
                    const invisibleHtml = generateInvisibleParagraphHtml();
                    logPaddingMessage(`    [L${lineIndex} Loop ${loopCount}] Generated invisibleHTML: ${invisibleHtml ? "Present" : "EMPTY"}`);

                    if (invisibleHtml) {
                        paddingSegmentBbcode = htmlToBbcode(invisibleHtml);
                        logPaddingMessage(`    [L${lineIndex} Loop ${loopCount}] Padding BBCode (RawLength ${paddingSegmentBbcode.length}, TextContentLength ${getTextContentLength(paddingSegmentBbcode)}): "${paddingSegmentBbcode.substring(0,50)}..."`);
                    }

                    if (!invisibleHtml || !paddingSegmentBbcode || getTextContentLength(paddingSegmentBbcode) === 0) { // Check text content of padding
                        logPaddingMessage(`    [L${lineIndex} Loop ${loopCount}] No valid phrase/HTML or padding BBCode has no text content. Trying minimal default.`);
                        currentTextContentLength = getTextContentLength(currentLine); // Re-check before adding minimal
                        if (currentTextContentLength < idealTextContentLength) {
                            const invisibleHexColor = getInvisibleTextColorHex();
                            const minimalPadding = `[color=${invisibleHexColor}]${CONFIG.MINIMAL_DEFAULT_INVISIBLE_CHAR}[/color]`;
                            currentLine += minimalPadding; // Add minimal padding
                            currentTextContentLength = getTextContentLength(currentLine); // Update text content length
                            logPaddingMessage(`      [L${lineIndex} Loop ${loopCount}] Using minimal default. New TextContentLength: ${currentTextContentLength}`);
                            // If even minimal default doesn't increase text length enough or ideal is 0, break.
                            if (getTextContentLength(minimalPadding) === 0 && idealTextContentLength > 0) {
                                logPaddingMessage(`      [L${lineIndex} Loop ${loopCount}] Minimal default has no text content. Breaking to avoid infinite loop.`);
                                break;
                            }
                            // If after adding minimal, we are still short, the loop will continue. If minimal made it long enough, it will break next.

                        } else {
                             logPaddingMessage(`      [L${lineIndex} Loop ${loopCount}] Line already meets/exceeds ideal text content length. Breaking.`);
                            break; 
                        }
                    } else {
                        currentLine += paddingSegmentBbcode;
                        currentTextContentLength = getTextContentLength(currentLine); // Update after adding segment
                    }
                    logPaddingMessage(`    [L${lineIndex} Loop ${loopCount}] Line after adding segment (New RawLength ${currentLine.length}, New TextContentLength ${currentTextContentLength}): "${currentLine.substring(0, 100)}${currentLine.length > 100 ? "..." : ""}"`);
                }
                logPaddingMessage(`[Line ${lineIndex} END] Final padded line (RawLength ${currentLine.length}, TextContentLength ${currentTextContentLength}): "${currentLine.substring(0,100)}${currentLine.length > 100 ? "..." : ""}"`);
                paddedLines.push(currentLine);
            }
            logPaddingMessage("--- padLinesToIdealLength END ---");
            return paddedLines.join('\n');
        }


        // --- HTML to BBCode Conversion ---
        function htmlToBbcode(htmlString) {
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = htmlString;
            return convertNodeToBbcode(tempDiv);
        }

        function convertNodeToBbcode(node) {
            let bbcode = "";
            node.childNodes.forEach(child => {
                if (child.nodeType === Node.TEXT_NODE) {
                    bbcode += child.textContent;
                } else if (child.nodeType === Node.ELEMENT_NODE) {
                    let currentStyle = child.getAttribute('style') || "";
                    
                    let colorMatch = currentStyle.match(/color:\s*rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
                    let hexColor = null;
                    if (colorMatch) {
                        hexColor = _rgbToHex(parseInt(colorMatch[1]), parseInt(colorMatch[2]), parseInt(colorMatch[3]));
                    }

                    let prefix = "";
                    let suffix = "";

                    if (hexColor) {
                        prefix += `[color=${hexColor}]`;
                        suffix = `[/color]` + suffix;
                    }
                    
                    bbcode += prefix;
                    bbcode += convertNodeToBbcode(child); 
                    bbcode += suffix;
                }
            });
            return bbcode;
        }

        // --- Event Listeners ---
        document.getElementById('applyWatermarkBtn').addEventListener('click', applyWatermark);
        document.getElementById('copyBbcodeBtn').addEventListener('click', () => {
            const bbcodeOutput = document.getElementById('bbcodeOutput');
            bbcodeOutput.select();
            bbcodeOutput.setSelectionRange(0, 99999); 

            try {
                const successful = document.execCommand('copy');
                const msg = successful ? 'BBCode copied to clipboard!' : 'Copying failed.';
                document.getElementById('copyStatus').textContent = msg;
                if(!successful) console.error('Fallback: Oops, unable to copy');
            } catch (err)
                {
                console.error('Fallback: Oops, unable to copy', err);
                document.getElementById('copyStatus').textContent = 'Copying failed (error).';
            }
            window.getSelection().removeAllRanges();
        });

        // --- Initial Load ---
        window.onload = () => {
            loadCustomPhrases();
            const htmlPreviewDiv = document.getElementById('htmlPreview');
            const targetBgHex = _rgbToHex(CONFIG.BACKGROUND_COLOR.r, CONFIG.BACKGROUND_COLOR.g, CONFIG.BACKGROUND_COLOR.b);
            htmlPreviewDiv.style.backgroundColor = targetBgHex;
        };
    </script>
</body>
</html>
